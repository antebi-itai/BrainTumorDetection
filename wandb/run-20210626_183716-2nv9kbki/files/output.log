> /home/labs/waic/itaian/BrainTumorDetection/train.py(12)train()
     10         for images, tumor_types in loader:
     11             import pdb; pdb.set_trace()
---> 12             images, tumor_types = images.to(device=device), tumor_types.to(device=device)
     13             # Run the model on the input batch
     14             pred_tumors_scores = model(images)
  0%|          | 0/3 [00:00<?, ?it/s]
100
100
tensor([0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0,
        1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1,
        1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1,
        0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0,
        1, 1, 0, 0])
*** NameError: name 'plt' is not defined
*** TypeError: Invalid shape (3, 256, 256) for image data
<matplotlib.image.AxesImage object at 0x2adcd31dc910>
device(type='cpu')
'cuda'
*** TypeError: Invalid shape (3, 256, 256) for image data
<matplotlib.image.AxesImage object at 0x2adcd31dcbb0>
<matplotlib.image.AxesImage object at 0x2adcd1253e50>
<matplotlib.image.AxesImage object at 0x2adcd325c970>
<matplotlib.image.AxesImage object at 0x2adcd368fca0>
<matplotlib.image.AxesImage object at 0x2adcd36f4f40>
<matplotlib.image.AxesImage object at 0x2adcd3764220>
<matplotlib.image.AxesImage object at 0x2adcd37c64f0>
<matplotlib.image.AxesImage object at 0x2adcd382a850>
> /home/labs/waic/itaian/BrainTumorDetection/train.py(14)train()
     12             images, tumor_types = images.to(device=device), tumor_types.to(device=device)
     13             # Run the model on the input batch
---> 14             pred_tumors_scores = model(images)
     15
     16             # Calculate the loss (and acc) for this batch
> /home/labs/waic/itaian/BrainTumorDetection/train.py(17)train()
     15
     16             # Calculate the loss (and acc) for this batch
---> 17             loss = criterion(pred_tumors_scores, tumor_types)
     18             wandb.log({"Train/loss": loss})
     19             for tumor_type, tumor_name in loader.dataset.tumor_type2name.items():
tensor([[-0.0463,  0.1436],
        [-0.2980, -0.1146],
        [ 0.0868,  0.2560],
        [-0.3350, -0.4300],
        [ 0.2125, -0.3564],
        [ 0.1313, -0.2838],
        [ 0.0146,  0.1209],
        [-0.3163, -0.0278],
        [-0.2787, -0.0178],
        [-0.5729,  0.1485],
        [ 0.0920, -0.1607],
        [-0.1400,  0.1728],
        [-0.1368, -0.2273],
        [-0.4489,  0.3983],
        [-0.1220,  0.2599],
        [ 0.3188, -0.0790],
        [ 0.6937,  0.1035],
        [ 0.0483,  0.9437],
        [-0.8482, -0.1021],
        [ 0.3801,  0.2934],
        [-0.2768, -0.1313],
        [ 0.0967,  0.2054],
        [-0.6638,  0.6867],
        [ 0.2887, -0.0519],
        [-0.6535, -0.3375],
        [ 0.0148,  0.5199],
        [ 0.4654, -0.1194],
        [-0.1291,  0.1946],
        [-0.1963, -0.1780],
        [-0.0962,  0.2464],
        [-0.0954,  0.3668],
        [-0.3650, -0.1762],
        [ 0.5721,  0.5201],
        [-0.3438, -0.0098],
        [-0.1327,  0.1085],
        [-0.1372,  0.7268],
        [ 0.0225, -0.0379],
        [-0.1442,  0.5907],
        [-0.1349,  0.3254],
        [-0.0824,  0.1568],
        [-0.0831,  0.2128],
        [-0.0049, -0.3467],
        [-0.1908, -0.4464],
        [-0.4555,  0.0433],
        [-0.1315, -1.0044],
        [ 0.2265,  0.2902],
        [ 0.4837,  0.1678],
        [-0.0508,  0.1135],
        [-0.3381,  0.1126],
        [ 0.2046,  0.1202],
        [-0.7161, -0.0564],
        [-0.1569,  0.1601],
        [ 0.3736,  0.1691],
        [-0.3857,  0.1649],
        [-0.1332, -0.0971],
        [-0.1297, -0.1530],
        [-0.1805,  0.3593],
        [ 0.3168,  0.6606],
        [ 0.0338,  0.4989],
        [-0.2662, -0.1575],
        [-0.5633, -0.1321],
        [ 0.0205,  0.8447],
        [ 0.0547, -0.4918],
        [-0.0124,  0.1529],
        [-0.4502,  0.5716],
        [-0.1226,  0.6530],
        [ 0.1367,  0.0877],
        [ 0.2097,  0.3952],
        [ 0.2899,  0.2980],
        [-0.5907,  0.2333],
        [ 0.4358, -0.2725],
        [-0.3457, -0.4410],
        [ 0.2340, -0.2294],
        [-0.1404,  0.4638],
        [-0.0016, -0.2315],
        [ 0.2679,  0.0122],
        [ 0.1204, -0.1208],
        [ 0.0059,  0.0688],
        [-0.1691,  0.4740],
        [ 0.2131, -0.3293],
        [-0.2237,  0.4321],
        [ 0.3209, -0.3697],
        [-0.2030,  0.3932],
        [-0.3682,  0.3908],
        [ 0.0379,  0.0816],
        [ 0.1666, -0.8158],
        [-0.3176, -0.4555],
        [-0.0497, -0.4417],
        [-0.3068,  0.0412],
        [-0.0123, -0.5193],
        [ 0.3092,  0.2358],
        [-0.0388, -0.8052],
        [-0.1734,  0.3777],
        [ 0.3747,  0.1839],
        [ 0.0377,  0.4919],
        [ 0.2237, -0.3890],
        [-0.8087, -0.0612],
        [-0.2595, -0.0190],
        [ 0.4772, -0.1693],
        [-0.1072,  0.2736]], device='cuda:0', grad_fn=<AddmmBackward>)
torch.Size([100, 2])
tensor([0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0,
        1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1,
        1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1,
        0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0,
        1, 1, 0, 0], device='cuda:0')
torch.Size([100])
> /home/labs/waic/itaian/BrainTumorDetection/train.py(18)train()
     16             # Calculate the loss (and acc) for this batch
     17             loss = criterion(pred_tumors_scores, tumor_types)
---> 18             wandb.log({"Train/loss": loss})
     19             for tumor_type, tumor_name in loader.dataset.tumor_type2name.items():
     20                 tumor_acc = accuracy(pred_tumors_scores, tumor_types, tumor_type=tumor_type)
tensor(0.7009, device='cuda:0', grad_fn=<NllLossBackward>)
> /home/labs/waic/itaian/BrainTumorDetection/train.py(19)train()
     17             loss = criterion(pred_tumors_scores, tumor_types)
     18             wandb.log({"Train/loss": loss})
---> 19             for tumor_type, tumor_name in loader.dataset.tumor_type2name.items():
     20                 tumor_acc = accuracy(pred_tumors_scores, tumor_types, tumor_type=tumor_type)
     21                 wandb.log({"Train/accuracy/{tumor_name}".format(tumor_name=tumor_name): tumor_acc})
dict_items([(0, 'no'), (1, 'yes')])
> /home/labs/waic/itaian/BrainTumorDetection/train.py(20)train()
     18             wandb.log({"Train/loss": loss})
     19             for tumor_type, tumor_name in loader.dataset.tumor_type2name.items():
---> 20                 tumor_acc = accuracy(pred_tumors_scores, tumor_types, tumor_type=tumor_type)
     21                 wandb.log({"Train/accuracy/{tumor_name}".format(tumor_name=tumor_name): tumor_acc})
     22             acc = accuracy(pred_tumors_scores, tumor_types, tumor_type=None)
> /home/labs/waic/itaian/BrainTumorDetection/train.py(21)train()
     19             for tumor_type, tumor_name in loader.dataset.tumor_type2name.items():
     20                 tumor_acc = accuracy(pred_tumors_scores, tumor_types, tumor_type=tumor_type)
---> 21                 wandb.log({"Train/accuracy/{tumor_name}".format(tumor_name=tumor_name): tumor_acc})
     22             acc = accuracy(pred_tumors_scores, tumor_types, tumor_type=None)
     23             wandb.log({"Train/accuracy": acc})
> /home/labs/waic/itaian/BrainTumorDetection/train.py(19)train()
     17             loss = criterion(pred_tumors_scores, tumor_types)
     18             wandb.log({"Train/loss": loss})
---> 19             for tumor_type, tumor_name in loader.dataset.tumor_type2name.items():
     20                 tumor_acc = accuracy(pred_tumors_scores, tumor_types, tumor_type=tumor_type)
     21                 wandb.log({"Train/accuracy/{tumor_name}".format(tumor_name=tumor_name): tumor_acc})
> /home/labs/waic/itaian/BrainTumorDetection/train.py(20)train()
     18             wandb.log({"Train/loss": loss})
     19             for tumor_type, tumor_name in loader.dataset.tumor_type2name.items():
---> 20                 tumor_acc = accuracy(pred_tumors_scores, tumor_types, tumor_type=tumor_type)
     21                 wandb.log({"Train/accuracy/{tumor_name}".format(tumor_name=tumor_name): tumor_acc})
     22             acc = accuracy(pred_tumors_scores, tumor_types, tumor_type=None)
> /home/labs/waic/itaian/BrainTumorDetection/train.py(21)train()
     19             for tumor_type, tumor_name in loader.dataset.tumor_type2name.items():
     20                 tumor_acc = accuracy(pred_tumors_scores, tumor_types, tumor_type=tumor_type)
---> 21                 wandb.log({"Train/accuracy/{tumor_name}".format(tumor_name=tumor_name): tumor_acc})
     22             acc = accuracy(pred_tumors_scores, tumor_types, tumor_type=None)
     23             wandb.log({"Train/accuracy": acc})
> /home/labs/waic/itaian/BrainTumorDetection/train.py(19)train()
     17             loss = criterion(pred_tumors_scores, tumor_types)
     18             wandb.log({"Train/loss": loss})
---> 19             for tumor_type, tumor_name in loader.dataset.tumor_type2name.items():
     20                 tumor_acc = accuracy(pred_tumors_scores, tumor_types, tumor_type=tumor_type)
     21                 wandb.log({"Train/accuracy/{tumor_name}".format(tumor_name=tumor_name): tumor_acc})
> /home/labs/waic/itaian/BrainTumorDetection/train.py(22)train()
     20                 tumor_acc = accuracy(pred_tumors_scores, tumor_types, tumor_type=tumor_type)
     21                 wandb.log({"Train/accuracy/{tumor_name}".format(tumor_name=tumor_name): tumor_acc})
---> 22             acc = accuracy(pred_tumors_scores, tumor_types, tumor_type=None)
     23             wandb.log({"Train/accuracy": acc})
     24
--Call--
> /home/labs/waic/itaian/BrainTumorDetection/loss.py(3)accuracy()
      1
      2
----> 3 def accuracy(pred_tumors_scores, gt_tumor_types, tumor_type=None):
      4         batch_size = gt_tumor_types.size(0)
      5         _, pred_tumors_types = pred_tumors_scores.max(dim=1)
> /home/labs/waic/itaian/BrainTumorDetection/loss.py(4)accuracy()
      2
      3 def accuracy(pred_tumors_scores, gt_tumor_types, tumor_type=None):
----> 4         batch_size = gt_tumor_types.size(0)
      5         _, pred_tumors_types = pred_tumors_scores.max(dim=1)
      6         if tumor_type is None:
> /home/labs/waic/itaian/BrainTumorDetection/loss.py(5)accuracy()
      3 def accuracy(pred_tumors_scores, gt_tumor_types, tumor_type=None):
      4         batch_size = gt_tumor_types.size(0)
----> 5         _, pred_tumors_types = pred_tumors_scores.max(dim=1)
      6         if tumor_type is None:
      7                 correct_predictions = (pred_tumors_types == gt_tumor_types).count_nonzero()
100
tensor([[-0.0463,  0.1436],
        [-0.2980, -0.1146],
        [ 0.0868,  0.2560],
        [-0.3350, -0.4300],
        [ 0.2125, -0.3564],
        [ 0.1313, -0.2838],
        [ 0.0146,  0.1209],
        [-0.3163, -0.0278],
        [-0.2787, -0.0178],
        [-0.5729,  0.1485],
        [ 0.0920, -0.1607],
        [-0.1400,  0.1728],
        [-0.1368, -0.2273],
        [-0.4489,  0.3983],
        [-0.1220,  0.2599],
        [ 0.3188, -0.0790],
        [ 0.6937,  0.1035],
        [ 0.0483,  0.9437],
        [-0.8482, -0.1021],
        [ 0.3801,  0.2934],
        [-0.2768, -0.1313],
        [ 0.0967,  0.2054],
        [-0.6638,  0.6867],
        [ 0.2887, -0.0519],
        [-0.6535, -0.3375],
        [ 0.0148,  0.5199],
        [ 0.4654, -0.1194],
        [-0.1291,  0.1946],
        [-0.1963, -0.1780],
        [-0.0962,  0.2464],
        [-0.0954,  0.3668],
        [-0.3650, -0.1762],
        [ 0.5721,  0.5201],
        [-0.3438, -0.0098],
        [-0.1327,  0.1085],
        [-0.1372,  0.7268],
        [ 0.0225, -0.0379],
        [-0.1442,  0.5907],
        [-0.1349,  0.3254],
        [-0.0824,  0.1568],
        [-0.0831,  0.2128],
        [-0.0049, -0.3467],
        [-0.1908, -0.4464],
        [-0.4555,  0.0433],
        [-0.1315, -1.0044],
        [ 0.2265,  0.2902],
        [ 0.4837,  0.1678],
        [-0.0508,  0.1135],
        [-0.3381,  0.1126],
        [ 0.2046,  0.1202],
        [-0.7161, -0.0564],
        [-0.1569,  0.1601],
        [ 0.3736,  0.1691],
        [-0.3857,  0.1649],
        [-0.1332, -0.0971],
        [-0.1297, -0.1530],
        [-0.1805,  0.3593],
        [ 0.3168,  0.6606],
        [ 0.0338,  0.4989],
        [-0.2662, -0.1575],
        [-0.5633, -0.1321],
        [ 0.0205,  0.8447],
        [ 0.0547, -0.4918],
        [-0.0124,  0.1529],
        [-0.4502,  0.5716],
        [-0.1226,  0.6530],
        [ 0.1367,  0.0877],
        [ 0.2097,  0.3952],
        [ 0.2899,  0.2980],
        [-0.5907,  0.2333],
        [ 0.4358, -0.2725],
        [-0.3457, -0.4410],
        [ 0.2340, -0.2294],
        [-0.1404,  0.4638],
        [-0.0016, -0.2315],
        [ 0.2679,  0.0122],
        [ 0.1204, -0.1208],
        [ 0.0059,  0.0688],
        [-0.1691,  0.4740],
        [ 0.2131, -0.3293],
        [-0.2237,  0.4321],
        [ 0.3209, -0.3697],
        [-0.2030,  0.3932],
        [-0.3682,  0.3908],
        [ 0.0379,  0.0816],
        [ 0.1666, -0.8158],
        [-0.3176, -0.4555],
        [-0.0497, -0.4417],
        [-0.3068,  0.0412],
        [-0.0123, -0.5193],
        [ 0.3092,  0.2358],
        [-0.0388, -0.8052],
        [-0.1734,  0.3777],
        [ 0.3747,  0.1839],
        [ 0.0377,  0.4919],
        [ 0.2237, -0.3890],
        [-0.8087, -0.0612],
        [-0.2595, -0.0190],
        [ 0.4772, -0.1693],
        [-0.1072,  0.2736]], device='cuda:0', grad_fn=<AddmmBackward>)
> /home/labs/waic/itaian/BrainTumorDetection/loss.py(6)accuracy()
      4         batch_size = gt_tumor_types.size(0)
      5         _, pred_tumors_types = pred_tumors_scores.max(dim=1)
----> 6         if tumor_type is None:
      7                 correct_predictions = (pred_tumors_types == gt_tumor_types).count_nonzero()
      8                 acc = correct_predictions / batch_size
tensor([1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0,
        1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1,
        1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0,
        0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0,
        1, 1, 0, 1], device='cuda:0')
> /home/labs/waic/itaian/BrainTumorDetection/loss.py(7)accuracy()
      5         _, pred_tumors_types = pred_tumors_scores.max(dim=1)
      6         if tumor_type is None:
----> 7                 correct_predictions = (pred_tumors_types == gt_tumor_types).count_nonzero()
      8                 acc = correct_predictions / batch_size
      9         else:
tensor([0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0,
        1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1,
        1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1,
        0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0,
        1, 1, 0, 0], device='cuda:0')
tensor([False, False,  True, False, False, False,  True,  True, False, False,
        False, False, False,  True,  True,  True, False, False, False, False,
        False, False,  True,  True,  True, False,  True, False,  True, False,
         True,  True, False,  True, False, False, False, False, False,  True,
         True, False,  True, False, False,  True,  True,  True,  True,  True,
         True,  True, False,  True,  True,  True,  True,  True,  True, False,
        False,  True, False, False,  True,  True, False, False, False, False,
         True, False,  True,  True, False, False, False,  True,  True,  True,
        False,  True, False, False,  True,  True, False,  True,  True,  True,
         True,  True, False, False, False,  True,  True,  True,  True, False],
       device='cuda:0')
> /home/labs/waic/itaian/BrainTumorDetection/loss.py(8)accuracy()
      6         if tumor_type is None:
      7                 correct_predictions = (pred_tumors_types == gt_tumor_types).count_nonzero()
----> 8                 acc = correct_predictions / batch_size
      9         else:
     10                 correct_tumor_predictions = ((pred_tumors_types == gt_tumor_types) & (gt_tumor_types == tumor_type)).count_nonzero()
tensor(51, device='cuda:0')
> /home/labs/waic/itaian/BrainTumorDetection/loss.py(13)accuracy()
      9         else:
     10                 correct_tumor_predictions = ((pred_tumors_types == gt_tumor_types) & (gt_tumor_types == tumor_type)).count_nonzero()
     11                 tumor_batch_size = (gt_tumor_types == tumor_type).count_nonzero()
     12                 acc = correct_tumor_predictions / tumor_batch_size
---> 13         return acc
--Return--
tensor(0.5100...vice='cuda:0')
> /home/labs/waic/itaian/BrainTumorDetection/loss.py(13)accuracy()
      9         else:
     10                 correct_tumor_predictions = ((pred_tumors_types == gt_tumor_types) & (gt_tumor_types == tumor_type)).count_nonzero()
     11                 tumor_batch_size = (gt_tumor_types == tumor_type).count_nonzero()
     12                 acc = correct_tumor_predictions / tumor_batch_size
---> 13         return acc
> /home/labs/waic/itaian/BrainTumorDetection/train.py(23)train()
     21                 wandb.log({"Train/accuracy/{tumor_name}".format(tumor_name=tumor_name): tumor_acc})
     22             acc = accuracy(pred_tumors_scores, tumor_types, tumor_type=None)
---> 23             wandb.log({"Train/accuracy": acc})
     24
     25             # Calculate the gradients of all parameter w.r.t. the loss
tensor(0.5100, device='cuda:0')
> /home/labs/waic/itaian/BrainTumorDetection/train.py(26)train()
     24
     25             # Calculate the gradients of all parameter w.r.t. the loss
---> 26             optimizer.zero_grad()
     27             backward(loss)
     28             # Update the weights (learn!)
VGGNet(
  (model): VGG(
    (features): Sequential(
      (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (1): ReLU(inplace=True)
      (2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (3): ReLU(inplace=True)
      (4): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (5): Conv2d(64, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (6): ReLU(inplace=True)
      (7): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (8): ReLU(inplace=True)
      (9): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (10): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (11): ReLU(inplace=True)
      (12): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (13): ReLU(inplace=True)
      (14): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (15): ReLU(inplace=True)
      (16): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (17): ReLU(inplace=True)
      (18): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (19): Conv2d(256, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (20): ReLU(inplace=True)
      (21): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (22): ReLU(inplace=True)
      (23): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (24): ReLU(inplace=True)
      (25): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (26): ReLU(inplace=True)
      (27): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
      (28): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (29): ReLU(inplace=True)
      (30): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (31): ReLU(inplace=True)
      (32): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (33): ReLU(inplace=True)
      (34): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (35): ReLU(inplace=True)
      (36): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    )
    (avgpool): AdaptiveAvgPool2d(output_size=(7, 7))
    (classifier): Sequential(
      (0): Linear(in_features=25088, out_features=4096, bias=True)
      (1): ReLU(inplace=True)
      (2): Dropout(p=0.5, inplace=False)
      (3): Linear(in_features=4096, out_features=4096, bias=True)
      (4): ReLU(inplace=True)
      (5): Dropout(p=0.5, inplace=False)
      (6): Linear(in_features=4096, out_features=2, bias=True)
    )
  )
)
*** AttributeError: 'VGGNet' object has no attribute 'features'
*** AttributeError: 'VGGNet' object has no attribute 'modell'
*** AttributeError: 'VGGNet' object has no attribute 'mode'
VGG(
  (features): Sequential(
    (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (1): ReLU(inplace=True)
    (2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (3): ReLU(inplace=True)
    (4): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (5): Conv2d(64, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (6): ReLU(inplace=True)
    (7): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (8): ReLU(inplace=True)
    (9): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (10): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (11): ReLU(inplace=True)
    (12): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (13): ReLU(inplace=True)
    (14): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (15): ReLU(inplace=True)
    (16): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (17): ReLU(inplace=True)
    (18): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (19): Conv2d(256, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (20): ReLU(inplace=True)
    (21): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (22): ReLU(inplace=True)
    (23): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (24): ReLU(inplace=True)
    (25): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (26): ReLU(inplace=True)
    (27): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (28): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (29): ReLU(inplace=True)
    (30): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (31): ReLU(inplace=True)
    (32): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (33): ReLU(inplace=True)
    (34): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (35): ReLU(inplace=True)
    (36): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
  )
  (avgpool): AdaptiveAvgPool2d(output_size=(7, 7))
  (classifier): Sequential(
    (0): Linear(in_features=25088, out_features=4096, bias=True)
    (1): ReLU(inplace=True)
    (2): Dropout(p=0.5, inplace=False)
    (3): Linear(in_features=4096, out_features=4096, bias=True)
    (4): ReLU(inplace=True)
    (5): Dropout(p=0.5, inplace=False)
    (6): Linear(in_features=4096, out_features=2, bias=True)
  )
  0%|          | 0/3 [15:20<?, ?it/s]
[34m[1mwandb[39m[22m: [32m[41mERROR[39m[49m Control-C detected -- Run data was not synced
--KeyboardInterrupt--
